<style>
  body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #0f0f0f; /* dark, not full black */
  }
  canvas {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    pointer-events: none;
    background: #0f0f0f; /* match not-quite-black background */
  }
</style>

<canvas id="dotted-lines-stage"></canvas>
<script>
// Memory-efficient: uses canvas, NOT a div per dot

const SPACING_X = 12;
const SPACING_Y = 12;
const DOT_SIZE = 8;

const MIN_COLS = 28;
const MIN_ROWS = 28;

let cols = 0, rows = 0;
let grid = null; // Only store "dead" or not (bit array)
let offsetX = 0, offsetY = 0;
let lastW = 0, lastH = 0;
let animationRunning = false;

// Calculate grid and dead-dot field ONCE (not per frame), only keep 1 bit per dot for "dead"
function computeGrid() {
  const width = window.innerWidth;
  const height = window.innerHeight;

  cols = Math.max(Math.floor((width - DOT_SIZE) / SPACING_X) + 1, MIN_COLS);
  rows = Math.max(Math.floor((height - DOT_SIZE) / SPACING_Y) + 1, MIN_ROWS);

  const GLITCH_END_ROWS = Math.floor(rows * 0.82);
  const MAX_DEAD_PROB = 0.995;

  const gridWidth = (cols - 1) * SPACING_X + DOT_SIZE;
  const gridHeight = (rows - 1) * SPACING_Y + DOT_SIZE;

  offsetX = Math.max(0, (width - gridWidth) / 2);
  offsetY = Math.max(0, (height - gridHeight) / 2);

  // Store as flat 0/1 array (bit array also possible, but this is simple + light)
  grid = new Uint8Array(cols * rows);
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      let isDead = 0;
      if (row < GLITCH_END_ROWS) {
        const n = 1 - row / GLITCH_END_ROWS;
        const curved =
          Math.pow(n, 5.2) * 0.6 +
          Math.pow(n, 1.1) * 0.4;
        const columnBias = (Math.sin(col * 0.9) + 1) * 0.15;
        const deadProb = Math.min(
          1,
          MAX_DEAD_PROB * curved + columnBias
        );
        if (Math.random() < deadProb) {
          isDead = 1;
        }
      }
      grid[row * cols + col] = isDead;
    }
  }
}

function drawDots(ctx, t) {
  // Fill background with #0f0f0f (not full black)
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0); // reset any transforms
  ctx.fillStyle = "#0f0f0f";
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.restore();

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.fillStyle = "#fff";

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      if (grid[row * cols + col]) continue; // dead, skip
      // pattern
      const phase = (row + col) / 10 - t;
      const on = Math.sin(phase) > 0.6;
      if (!on) continue;
      const x = col * SPACING_X;
      const y = row * SPACING_Y;
      ctx.beginPath();
      ctx.arc(x, y, DOT_SIZE/2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.restore();
}

function doResize(canvas, ctx) {
  // Only recompute if size changed
  const w = window.innerWidth, h = window.innerHeight;
  if (w === lastW && h === lastH && grid) return;
  lastW = w; lastH = h;
  // Set canvas size (hiDPI aware)
  const dpr = window.devicePixelRatio || 1;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  // Update grid
  computeGrid();
}

(function() {
  const canvas = document.getElementById("dotted-lines-stage");
  const ctx = canvas.getContext("2d", {alpha:false});
  let t = 0;

  function animate() {
    if (!animationRunning) return;
    drawDots(ctx, t);
    t += 0.005; // MADE EVEN SLOWER for "make speed slow"
    requestAnimationFrame(animate);
  }

  function start() {
    doResize(canvas, ctx);
    animationRunning = true;
    requestAnimationFrame(animate);
  }
  function stop() {
    animationRunning = false;
  }

  window.addEventListener("DOMContentLoaded", start);
  window.addEventListener("resize", function() {
    doResize(canvas, ctx);
  });

  // Memory-efficient pause/resume on tab visibility
  document.addEventListener("visibilitychange", function() {
    if (document.visibilityState === "visible") {
      if (!animationRunning) {
        doResize(canvas, ctx);
        animationRunning = true;
        requestAnimationFrame(animate);
      }
    } else {
      animationRunning = false;
      // Free memory: remove grid, clear canvas
      grid = null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Also refill with #0f0f0f, so blank frame isn't pure black
      ctx.save();
      ctx.fillStyle = "#0f0f0f";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
  });
})();
</script>