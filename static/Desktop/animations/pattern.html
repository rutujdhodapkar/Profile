<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Selective Dot Emergence â€“ Inverted, Left=UltraLow, Mid=VeryLow, Right=High</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: auto;
    background: #0f0f0f;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .dot {
    position: absolute;
    border-radius: 50%;
    background: #c9c9c9;
    pointer-events: none;
    transform-origin: center;
    will-change: width, height;
  }

  html::-webkit-scrollbar,
  body::-webkit-scrollbar {
    display: none;
  }
</style>
</head>

<body>
<script>
/* ---------------- CONFIG ---------------- */

const SPACING_X = 12;
const SPACING_Y = 12;

const HIDDEN_SIZE = 0;
const AMBIENT_SIZE = 1.2;
const WATER_SIZE = 6.8;
const FOAM_SIZE  = 8.5;

const SEA_HEIGHT_ROWS = 10;
const FOAM_THICKNESS = 2;

const RIGHT_EXTRA = 36;
const LEFT_EXTRA  = 0.02;
const MID_EXTRA   = 0.15;

const AMBIENT_CHANCE = 0.04;

// Commented out the minimums so grid will only cover viewport
// const MIN_COLS = 28;
// const MIN_ROWS = 28;
const EXTRA_ROWS = 0; // removed extra rows for exact viewport fit

/* ---------------- STATE ---------------- */

let dots = [];
let positions = [];
let cols = 0;
let rows = 0;
let animationRunning = false;
let animationFrameId = null;

/* ---------------- GRID ---------------- */

function createGrid() {
  dots.forEach(d => d.remove());
  dots = [];
  positions = [];

  // Only make enough cols/rows for viewport
  cols = Math.ceil(window.innerWidth / SPACING_X);
  rows = Math.ceil(window.innerHeight / SPACING_Y);

  document.body.style.minHeight = (rows * SPACING_Y) + "px";

  const frag = document.createDocumentFragment();

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const dot = document.createElement("div");
      dot.className = "dot";
      dot.style.left = c * SPACING_X + "px";
      dot.style.top  = r * SPACING_Y + "px";
      dot.style.width = HIDDEN_SIZE + "px";
      dot.style.height = HIDDEN_SIZE + "px";
      dot._size = HIDDEN_SIZE;

      if (Math.random() < AMBIENT_CHANCE) dot._ambient = true;

      frag.appendChild(dot);
      dots.push(dot);
      positions.push({ r, c });
    }
  }

  document.body.appendChild(frag);
}

// Utility function: only update if value changed (for style.width/height)
function setDotSize(dot, size) {
  // Use a property to cache last set value for efficiency
  if (dot._size !== size) {
    dot.style.width = size + "px";
    dot.style.height = size + "px";
    dot._size = size;
  }
}

/* ---------------- ANIMATION ---------------- */

function animate() {
  if (!animationRunning) return;

  const SEA_ANIMATION_SPEED = 0.40;
  const t = performance.now() * 0.001 * SEA_ANIMATION_SPEED;

  // Precompute the surface, and also localSeaHeight for each col, to avoid recomputation
  const surface = new Array(cols);
  const localSeaHeights = new Array(cols);

  for (let c = 0; c < cols; c++) {
    const leftNorm = cols < 2 ? 0 : c / (cols - 1);

    let heightBoost;
    if (leftNorm <= 0.33) {
      heightBoost = LEFT_EXTRA + (MID_EXTRA - LEFT_EXTRA) * (leftNorm / 0.33);
    } else if (leftNorm < 0.66) {
      heightBoost = MID_EXTRA;
    } else {
      heightBoost = MID_EXTRA + (RIGHT_EXTRA - MID_EXTRA) * ((leftNorm - 0.66) / (1 - 0.66));
    }
    localSeaHeights[c] = SEA_HEIGHT_ROWS + heightBoost;
    const currentSeaHeight = localSeaHeights[c];
    surface[c] =
      currentSeaHeight +
      Math.sin(c * 0.12 + t * 0.8) * 2.4 +
      Math.sin(c * 0.27 - t * 1.1) * 1.2 +
      Math.cos(c * 0.18 + t) * 0.6;
  }

  // Animate each dot: only update size if necessary, and batch calculations where possible
  for (let i = 0; i < dots.length; i++) {
    const dot = dots[i];
    const { r, c } = positions[i];

    const s = surface[c];
    const localSeaHeight = localSeaHeights[c];

    // Only update ambient dots if size actually changes
    if (dot._ambient) {
      if (r >= s && r > s + FOAM_THICKNESS) {
        // Only show ambient if not sea or foam
        setDotSize(dot, AMBIENT_SIZE);
        continue;
      }
    }

    // Efficiently only set to hidden if not sea, not foam, not ambient
    if (r < s) {
      const depth = Math.min(1, (s - r) / localSeaHeight);
      const pulse = Math.sin(t * 1.4 + r * 0.4 + c * 0.3) * 0.6;
      const size = WATER_SIZE * (1 - depth * 0.35) + pulse;

      setDotSize(dot, size);
    }
    else if (r <= s + FOAM_THICKNESS && r >= s - 0.3) {
      // Only compute foam's randomness if actually in foam
      const size =
        FOAM_SIZE +
        Math.sin(t * 7 + c * 0.9 + r) * 1.5 +
        Math.random() * 0.8;
      setDotSize(dot, size);
    }
    else {
      setDotSize(dot, dot._ambient ? AMBIENT_SIZE : HIDDEN_SIZE);
    }
  }

  animationFrameId = requestAnimationFrame(animate);
}

/* ---------------- VISIBILITY HANDLING ---------------- */
function onVisibilityChange() {
  if (document.visibilityState === "visible") {
    if (!animationRunning) {
      animationRunning = true;
      animate();
    }
  } else {
    animationRunning = false;
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
  }
}

/* ---------------- INIT ---------------- */

addEventListener("load", () => {
  createGrid();
  animationRunning = true;
  animate();
  document.addEventListener("visibilitychange", onVisibilityChange);
});
addEventListener("resize", createGrid);

</script>
</body>
</html>
