<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Selective Dot Emergence â€“ Canvas Renderer (memory optimized)</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #0f0f0f;
    scrollbar-width: none;
    -ms-overflow-style: none;
    height: 100%;
    width: 100%;
  }

  canvas {
    display: block;
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    background: #0f0f0f;
  }
  /* Overlay completely hidden for memory auto-pause */
  #pause-overlay {
    display: none !important;
  }
</style>
</head>

<body>
<canvas id="stage"></canvas>
<!-- Overlay removed from DOM to prevent a white screen on memory pause -->

<script>
/* ---------------- CONFIG ---------------- */
const SPACING_X = 12;
const SPACING_Y = 12;

const HIDDEN_SIZE = 0;
const AMBIENT_SIZE = 1.2;
const WATER_SIZE = 6.8;
const FOAM_SIZE  = 8.5;

const SEA_HEIGHT_ROWS = 10;
const FOAM_THICKNESS = 2;

const RIGHT_EXTRA = 36;
const LEFT_EXTRA  = 0.02;
const MID_EXTRA   = 0.15;

const AMBIENT_CHANCE = 0.04;
const EXTRA_ROWS = 0;

const MAX_DOTS = 18000;
const MIN_FRAME_INTERVAL_MS = 1000 / 40;

/* ---------------- STATE ---------------- */
const canvas = document.getElementById("stage");
const ctx = canvas.getContext("2d", { alpha: false });
let pixelRatio = Math.max(1, window.devicePixelRatio || 1);
let cols = 0, rows = 0;
let spacingX = SPACING_X, spacingY = SPACING_Y;
let lastFrameTime = 0;
let perFrameSizes = null;
let ambientFlags = null;
let animationRunning = false;

// --- Memory-pause handling ---
let pauseManually = false;
let pausedDueToHidden = false;

/* ---------------- GRID ---------------- */
function resizeCanvas() {
  pixelRatio = Math.max(1, window.devicePixelRatio || 1);
  const cssW = Math.max(1, window.innerWidth);
  const cssH = Math.max(1, window.innerHeight);
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width = Math.floor(cssW * pixelRatio);
  canvas.height = Math.floor(cssH * pixelRatio);
  ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
}

function createGrid() {
  spacingX = SPACING_X;
  spacingY = SPACING_Y;
  let tentativeCols = Math.floor(window.innerWidth / spacingX);
  let tentativeRows = Math.floor(window.innerHeight / spacingY);
  let tentativeTotal = tentativeCols * tentativeRows;
  if (tentativeTotal > MAX_DOTS) {
    const scale = Math.sqrt(tentativeTotal / MAX_DOTS);
    const multiplier = Math.ceil(scale);
    spacingX = SPACING_X * multiplier;
    spacingY = SPACING_Y * multiplier;
  }
  cols = Math.max(1, Math.ceil(window.innerWidth / spacingX));
  rows = Math.max(1, Math.ceil(window.innerHeight / spacingY));
  resizeCanvas();

  // Instead of re-allocating every frame, reuse buffers for memory efficiency.
  const total = cols * rows;
  if (!perFrameSizes || perFrameSizes.length !== total) {
    perFrameSizes = new Float32Array(total);
    ambientFlags = new Uint8Array(total);
    for (let i = 0; i < total; i++) {
      perFrameSizes[i] = HIDDEN_SIZE;
      ambientFlags[i] = Math.random() < AMBIENT_CHANCE ? 1 : 0;
    }
  } else {
    perFrameSizes.fill(HIDDEN_SIZE);
  }
}

function dynamicSeaHeight(r, c, maxRows, maxCols) {
  const rowNorm = maxRows < 2 ? 0 : (r / (maxRows - 1));
  const colNorm = maxCols < 2 ? 0 : (c / (maxCols - 1));
  let rowLeft = LEFT_EXTRA + (0.18 * rowNorm);
  let rowMid  = MID_EXTRA + (0.33 * rowNorm);
  let rowRight = RIGHT_EXTRA * (0.6 + 0.4 * rowNorm);
  let boost;
  if (colNorm <= 0.33) {
    boost = rowLeft + (rowMid - rowLeft) * (colNorm / 0.33);
  } else if (colNorm < 0.66) {
    boost = rowMid;
  } else {
    boost = rowMid + (rowRight - rowMid) * ((colNorm - 0.66) / (1 - 0.66));
  }
  return SEA_HEIGHT_ROWS + boost;
}

/* ---------------- ANIMATION ---------------- */
function animate(now) {
  if (!animationRunning || pauseManually || pausedDueToHidden) {
    animationRunning = false;
    return;
  }
  if (!now) now = performance.now();
  if (now - lastFrameTime < MIN_FRAME_INTERVAL_MS) {
    requestAnimationFrame(animate);
    return;
  }
  lastFrameTime = now;
  const SEA_ANIMATION_SPEED = 0.40;
  const t = now * 0.001 * SEA_ANIMATION_SPEED;

  ctx.fillStyle = "#0f0f0f";
  ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
  ctx.fillStyle = "#c9c9c9";
  for (let i = 0; i < perFrameSizes.length; i++) {
    const r = Math.floor(i / cols);
    const c = i % cols;
    const currentSeaHeight = dynamicSeaHeight(r, c, rows, cols);
    const s =
      currentSeaHeight +
      Math.sin(c * 0.12 + r * 0.14 + t * 0.8) * 2.4 +
      Math.sin(c * 0.27 + r * 0.21 - t * 1.1) * 1.2 +
      Math.cos(c * 0.18 + r * 0.09 + t) * 0.6;

    if (ambientFlags[i]) {
      if (r >= s && r > s + FOAM_THICKNESS) {
        perFrameSizes[i] = AMBIENT_SIZE;
      }
    }

    if (r < s) {
      const depth = Math.min(1, (s - r) / currentSeaHeight);
      const pulse = Math.sin(t * 1.4 + r * 0.4 + c * 0.3) * 0.6;
      const size = WATER_SIZE * (1 - depth * 0.35) + pulse;
      perFrameSizes[i] = size;
    } else if (r <= s + FOAM_THICKNESS && r >= s - 0.3) {
      const size = FOAM_SIZE + Math.sin(t * 7 + c * 0.9 + r) * 1.5 + Math.random() * 0.8;
      perFrameSizes[i] = size;
    } else {
      perFrameSizes[i] = ambientFlags[i] ? AMBIENT_SIZE : HIDDEN_SIZE;
    }

    const size = perFrameSizes[i];
    if (size > 0.001) {
      const x = c * spacingX + spacingX * 0.5;
      const y = r * spacingY + spacingY * 0.5;
      const radius = Math.max(0.5, size * 0.5);
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  requestAnimationFrame(animate);
}

/* ---------------- MEMORY-EFFICIENT PAUSE ---------------- */
// Pause animation in memory when tab/window is not visible (but do NOT show overlay)
function onVisibilityChange() {
  if (document.visibilityState === "visible") {
    pausedDueToHidden = false;
    if (!pauseManually && !animationRunning) {
      animationRunning = true;
      requestAnimationFrame(animate);
    }
  } else {
    pausedDueToHidden = true;
    animationRunning = false;
    // Overlay intentionally not shown for memory auto-pause
  }
}

// Allow user to pause with a key, but DO NOT show overlay (just stop animation)
window.addEventListener("keydown", function(e) {
  if ((e.code === "Space" || e.key === "p" || e.key === "P") && !pauseManually) {
    pauseManually = true;
    animationRunning = false;
    // Overlay intentionally not shown so memory pause is silent
    e.preventDefault();
  }
});

/* ---------------- INIT/RESUME/RESIZE ---------------- */
addEventListener("load", () => {
  createGrid();
  animationRunning = true;
  requestAnimationFrame(animate);
  document.addEventListener("visibilitychange", onVisibilityChange);
});
addEventListener("resize", () => {
  createGrid();
});
</script>
</body>
</html>
