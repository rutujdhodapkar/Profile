<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Selective Dot Emergence â€“ Inverted, Left=UltraLow, Mid=VeryLow, Right=High</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: auto;
    background: #0f0f0f;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .dot {
    position: absolute;
    border-radius: 50%;
    background: #c9c9c9;
    pointer-events: none;
    transform-origin: center;
    will-change: width, height;
  }

  html::-webkit-scrollbar,
  body::-webkit-scrollbar {
    display: none;
  }
</style>
</head>

<body>
<script>
/* ---------------- CONFIG ---------------- */

const SPACING_X = 12;
const SPACING_Y = 12;

const HIDDEN_SIZE = 0;
const AMBIENT_SIZE = 1.2;
const WATER_SIZE = 6.8;
const FOAM_SIZE  = 8.5;

const SEA_HEIGHT_ROWS = 10;
const FOAM_THICKNESS = 2;

// Lower left and middle even more, keep right as is
const RIGHT_EXTRA = 36;    // high wave at far right (unchanged!)
const LEFT_EXTRA  = 0.02;  // ultra low at far left
const MID_EXTRA   = 0.15;  // very low at mid (much less than before)

const AMBIENT_CHANCE = 0.04;

const MIN_COLS = 28;
const MIN_ROWS = 28;
const EXTRA_ROWS = 5;

/* ---------------- STATE ---------------- */

let dots = [];
let positions = [];
let cols = 0;
let rows = 0;

/* ---------------- GRID ---------------- */

function createGrid() {
  dots.forEach(d => d.remove());
  dots = [];
  positions = [];

  cols = Math.max(Math.floor(innerWidth / SPACING_X), MIN_COLS);
  rows = Math.max(Math.floor(innerHeight / SPACING_Y) + EXTRA_ROWS, MIN_ROWS);

  document.body.style.minHeight = rows * SPACING_Y + "px";

  const frag = document.createDocumentFragment();

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const dot = document.createElement("div");
      dot.className = "dot";
      dot.style.left = c * SPACING_X + "px";
      dot.style.top  = r * SPACING_Y + "px";
      dot.style.width = HIDDEN_SIZE + "px";
      dot.style.height = HIDDEN_SIZE + "px";

      if (Math.random() < AMBIENT_CHANCE) dot._ambient = true;

      frag.appendChild(dot);
      dots.push(dot);
      positions.push({ r, c });
    }
  }

  document.body.appendChild(frag);
}

/* ---------------- ANIMATION ---------------- */

function animate() {
  const t = performance.now() * 0.001;

  // reset
  for (let dot of dots) {
    const size = dot._ambient ? AMBIENT_SIZE : HIDDEN_SIZE;
    dot.style.width = size + "px";
    dot.style.height = size + "px";
  }

  // Generate heightBoost profile: left ultra low, mid very low, right high
  const surface = new Array(cols);
  for (let c = 0; c < cols; c++) {
    const leftNorm = cols < 2 ? 0 : c / (cols - 1);

    // Make left and mid much flatter, right unchanged
    let heightBoost;
    if (leftNorm <= 0.33) {
      // Fade from LEFT_EXTRA up to MID_EXTRA over left third (both ultra low and very low)
      heightBoost = LEFT_EXTRA + (MID_EXTRA - LEFT_EXTRA) * (leftNorm / 0.33);
    } else if (leftNorm < 0.66) {
      // Flat very low in middle
      heightBoost = MID_EXTRA;
    } else {
      // Fade from MID_EXTRA up to RIGHT_EXTRA over right third
      heightBoost = MID_EXTRA + (RIGHT_EXTRA - MID_EXTRA) * ((leftNorm - 0.66)/ (1 - 0.66));
    }

    const currentSeaHeight = SEA_HEIGHT_ROWS + heightBoost;

    surface[c] =
      currentSeaHeight +
      Math.sin(c * 0.12 + t * 0.8) * 2.4 +
      Math.sin(c * 0.27 - t * 1.1) * 1.2 +
      Math.cos(c * 0.18 + t) * 0.6;
  }

  // inverted sea
  for (let i = 0; i < dots.length; i++) {
    const { r, c } = positions[i];
    const s = surface[c];
    const leftNorm = cols < 2 ? 0 : c / (cols - 1);

    // Recompute the *local* heightBoost for this column, exactly as above
    let heightBoost;
    if (leftNorm <= 0.33) {
      heightBoost = LEFT_EXTRA + (MID_EXTRA - LEFT_EXTRA) * (leftNorm / 0.33);
    } else if (leftNorm < 0.66) {
      heightBoost = MID_EXTRA;
    } else {
      heightBoost = MID_EXTRA + (RIGHT_EXTRA - MID_EXTRA) * ((leftNorm - 0.66)/ (1 - 0.66));
    }
    const localSeaHeight = SEA_HEIGHT_ROWS + heightBoost;

    if (r < s) {
      const depth = Math.min(1, (s - r) / localSeaHeight);
      const pulse = Math.sin(t * 1.4 + r * 0.4 + c * 0.3) * 0.6;
      const size = WATER_SIZE * (1 - depth * 0.35) + pulse;

      dots[i].style.width = size + "px";
      dots[i].style.height = size + "px";
    }
    else if (r <= s + FOAM_THICKNESS && r >= s - 0.3) {
      const size =
        FOAM_SIZE +
        Math.sin(t * 7 + c * 0.9 + r) * 1.5 +
        Math.random() * 0.8;

      dots[i].style.width = size + "px";
      dots[i].style.height = size + "px";
    }
  }

  requestAnimationFrame(animate);
}

/* ---------------- INIT ---------------- */

addEventListener("load", () => {
  createGrid();
  animate();
});
addEventListener("resize", createGrid);
</script>
</body>
</html>
