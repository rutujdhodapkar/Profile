<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Selective Dot Emergence</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: auto;
    background: #0f0f0f;
    /* hide native scrollbars but keep scrolling enabled */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE 10+ */
  }

  .dot {
    position: absolute;
    border-radius: 50%;
    background: #c9c9c9;
    pointer-events: none;
    transform-origin: center;
    will-change: width, height;
  }

/* WebKit scrollbar hide */
html::-webkit-scrollbar, body::-webkit-scrollbar {
  display: none;
  width: 0;
  height: 0;
}
</style>
</head>

<body>
<script>
/* ---------------- CONFIG ---------------- */

const SPACING_X = 12;
const SPACING_Y = 12;

const HIDDEN_SIZE = 0;
const AMBIENT_SIZE = 1.2;
const RAIN_SIZE = 6.5;
const WATER_SIZE = 6.8;
const FOAM_SIZE  = 8.5;

const SEA_HEIGHT_ROWS = 10;
const FOAM_THICKNESS = 2;

// Increased for "little more rain drops"
const RAIN_COLUMNS = 0.07;
// SLOW DOWN: Lower rain speed for slower drops
const RAIN_SPEED = 0.17; // ORIGINAL 0.35, now slower

const AMBIENT_CHANCE = 0.04;

const MIN_COLS = 28;
const MIN_ROWS = 28;
// Add a small number of extra rows so new rows below the viewport are created
const EXTRA_ROWS = 5;

/* ---------------- STATE ---------------- */

let dots = [];
let positions = [];
let cols = 0;
let rows = 0;
let rainDrops = [];

/* ---------------- GRID ---------------- */

function createGrid() {
  dots.forEach(d => d.remove());
  dots = [];
  positions = [];
  rainDrops = [];

  cols = Math.max(Math.floor(innerWidth / SPACING_X), MIN_COLS);
  // Allocate a few extra rows beyond the viewport so the user can scroll down
  rows = Math.max(Math.floor(innerHeight / SPACING_Y) + EXTRA_ROWS, MIN_ROWS);

  // Ensure the document body is tall enough to reveal the extra rows (enables scrollbar)
  document.body.style.minHeight = rows * SPACING_Y + "px";

  const frag = document.createDocumentFragment();

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const dot = document.createElement("div");
      dot.className = "dot";
      dot.style.left = c * SPACING_X + "px";
      dot.style.top  = r * SPACING_Y + "px";
      dot.style.width = HIDDEN_SIZE + "px";
      dot.style.height = HIDDEN_SIZE + "px";

      frag.appendChild(dot);
      dots.push(dot);
      positions.push({ r, c });

      if (Math.random() < AMBIENT_CHANCE) {
        dot._ambient = true;
      }
    }
  }

  // FIX: Make rain drop probability uniform (not left-leaning)
  // Instead of Math.random() per column, use a deterministic, evenly distributed assignment with some randomness
  // The point: make sure the *expected* number of drops is about the same, but the distribution is not skewed
  // (e.g. due to Math.random() idiosyncrasies in low/high indices)

  // Calculate target number of columns with rain drops
  const numRainColumns = Math.round(cols * RAIN_COLUMNS);

  // Pick numRainColumns unique columns with uniform randomness
  let rainColsArr = [];
  for (let c = 0; c < cols; c++) rainColsArr.push(c);
  // Shuffle (Fisher-Yates)
  for (let i = rainColsArr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [rainColsArr[i], rainColsArr[j]] = [rainColsArr[j], rainColsArr[i]];
  }
  rainColsArr = rainColsArr.slice(0, numRainColumns);

  for (const c of rainColsArr) {
    rainDrops.push({
      col: c,
      y: Math.random() * rows * 0.5,
      // Slow down the drops: reduce the max random speed as well
      speed: RAIN_SPEED + Math.random() * 0.13 // was 0.25
    });
  }

  document.body.appendChild(frag);
}

/* ---------------- ANIMATION ---------------- */

// Even slower sea animation multipliers
const SEA_WAVE_SPEED1 = 0.3;   // was 0.5, now slower
const SEA_WAVE_SPEED2 = 0.4;   // was 0.7, now slower
const SEA_WAVE_SPEED3 = 0.3;   // was 0.5, now slower
const SEA_PULSE_SPEED = 0.7;   // was 1.0, now slower
const FOAM_WAVE_SPEED = 2.7;   // was 4.0, now slower

let animationPaused = false;
let animFrameHandle = null;

function animate() {
  if (animationPaused) return;

  const t = performance.now() * 0.001;

  // reset everything
  for (let dot of dots) {
    const size = dot._ambient ? AMBIENT_SIZE : HIDDEN_SIZE;
    dot.style.width = size + "px";
    dot.style.height = size + "px";
  }

  // wave surface
  const surface = new Array(cols);
  for (let c = 0; c < cols; c++) {
    surface[c] =
      rows - SEA_HEIGHT_ROWS +
      Math.sin(c * 0.12 + t * SEA_WAVE_SPEED1) * 2.4 +
      Math.sin(c * 0.27 - t * SEA_WAVE_SPEED2) * 1.2 +
      Math.cos(c * 0.18 + t * SEA_WAVE_SPEED3) * 0.6;
  }

  // rain
  for (let drop of rainDrops) {
    drop.y += drop.speed;
    if (drop.y > rows) drop.y = -8;

    for (let r = Math.floor(drop.y); r > drop.y - 6; r--) {
      if (r < 0 || r >= rows) continue;
      const idx = r * cols + drop.col;
      dots[idx].style.width = RAIN_SIZE + "px";
      dots[idx].style.height = RAIN_SIZE + "px";
    }
  }

  // sea
  for (let i = 0; i < dots.length; i++) {
    const { r, c } = positions[i];
    const s = surface[c];

    if (r > s) {
      const depth = Math.min(1, (r - s) / SEA_HEIGHT_ROWS);
      const pulse = Math.sin(t * SEA_PULSE_SPEED + r * 0.4 + c * 0.3) * 0.6;
      const size = WATER_SIZE * (1 - depth * 0.35) + pulse;

      dots[i].style.width = size + "px";
      dots[i].style.height = size + "px";
    }

    else if (r >= s - FOAM_THICKNESS && r <= s + 0.3) {
      const size =
        FOAM_SIZE +
        Math.sin(t * FOAM_WAVE_SPEED + c * 0.9 + r) * 1.5 +
        Math.random() * 0.8;

      dots[i].style.width = size + "px";
      dots[i].style.height = size + "px";
    }
  }

  animFrameHandle = requestAnimationFrame(animate);
}

/* ---------------- VISIBILITY HANDLING ---------------- */

function onVisibilityChange() {
  if (document.hidden) {
    animationPaused = true;
    if (animFrameHandle !== null) {
      cancelAnimationFrame(animFrameHandle);
      animFrameHandle = null;
    }
  } else {
    if (animationPaused) {
      animationPaused = false;
      animate();
    }
  }
}
document.addEventListener("visibilitychange", onVisibilityChange);

/* ---------------- INIT ---------------- */

addEventListener("load", () => {
  createGrid();
  animate();
});

addEventListener("resize", createGrid);
</script>
</body>
</html>
