<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Selective Dot Emergence</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: auto;
    background: #0f0f0f;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE 10+ */
  }

  .dot {
    position: absolute;
    border-radius: 50%;
    background: #c9c9c9;
    pointer-events: none;
    transform-origin: center;
    will-change: width, height;
  }

/* WebKit scrollbar hide */
html::-webkit-scrollbar, body::-webkit-scrollbar {
  display: none;
  width: 0;
  height: 0;
}
</style>
</head>

<body>
<script>
/* ---------------- CONFIG ---------------- */

const SPACING_X = 12;
const SPACING_Y = 12;

const HIDDEN_SIZE = 0;
const AMBIENT_SIZE = 1.2;
const RAIN_SIZE = 6.5;
const WATER_SIZE = 6.8;
const FOAM_SIZE  = 8.5;

const SEA_HEIGHT_ROWS = 10;
const FOAM_THICKNESS = 2;

const RAIN_COLUMNS = 0.07;
const RAIN_SPEED = 0.17; 

const AMBIENT_CHANCE = 0.04;

const MIN_COLS = 28;
const MIN_ROWS = 28;
const EXTRA_ROWS = 5;

/* ---------------- STATE ---------------- */

let dots = [];
let positions = [];
let cols = 0;
let rows = 0;
let rainDrops = [];

// Cache dot sizes to avoid unnecessary DOM writes
let lastDotSizes = [];

/* ---------------- GRID ---------------- */

function createGrid() {
  dots.forEach(d => d.remove());
  dots = [];
  positions = [];
  rainDrops = [];
  lastDotSizes = [];

  cols = Math.max(Math.floor(innerWidth / SPACING_X), MIN_COLS);
  rows = Math.max(Math.floor(innerHeight / SPACING_Y) + EXTRA_ROWS, MIN_ROWS);

  document.body.style.minHeight = rows * SPACING_Y + "px";

  const frag = document.createDocumentFragment();

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const dot = document.createElement("div");
      dot.className = "dot";
      dot.style.left = c * SPACING_X + "px";
      dot.style.top  = r * SPACING_Y + "px";
      dot.style.width = HIDDEN_SIZE + "px";
      dot.style.height = HIDDEN_SIZE + "px";

      frag.appendChild(dot);
      dots.push(dot);
      positions.push({ r, c });
      lastDotSizes.push(HIDDEN_SIZE);

      if (Math.random() < AMBIENT_CHANCE) {
        dot._ambient = true;
      }
    }
  }

  // Calculate target number of columns with rain drops
  const numRainColumns = Math.round(cols * RAIN_COLUMNS);

  // Pick numRainColumns unique columns with uniform randomness
  let rainColsArr = [];
  for (let c = 0; c < cols; c++) rainColsArr.push(c);
  for (let i = rainColsArr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [rainColsArr[i], rainColsArr[j]] = [rainColsArr[j], rainColsArr[i]];
  }
  rainColsArr = rainColsArr.slice(0, numRainColumns);

  for (const c of rainColsArr) {
    rainDrops.push({
      col: c,
      y: Math.random() * rows * 0.5,
      speed: RAIN_SPEED + Math.random() * 0.13
    });
  }

  document.body.appendChild(frag);
}

/* ---------------- ANIMATION ---------------- */

const SEA_WAVE_SPEED1 = 0.3;
const SEA_WAVE_SPEED2 = 0.4;
const SEA_WAVE_SPEED3 = 0.3;
const SEA_PULSE_SPEED = 0.7;
const FOAM_WAVE_SPEED = 2.7;

let animationPaused = false;
let animFrameHandle = null;

// Batch DOM updates using requestAnimationFrame and apply only changed styles
function animate() {
  if (animationPaused) return;

  const t = performance.now() * 0.001;

  // Precompute for efficiency
  const surface = new Array(cols);
  for (let c = 0; c < cols; c++) {
    surface[c] =
      rows - SEA_HEIGHT_ROWS +
      Math.sin(c * 0.12 + t * SEA_WAVE_SPEED1) * 2.4 +
      Math.sin(c * 0.27 - t * SEA_WAVE_SPEED2) * 1.2 +
      Math.cos(c * 0.18 + t * SEA_WAVE_SPEED3) * 0.6;
  }

  // Generate frame dotSize array, default to 0 (hidden)
  const newDotSizes = new Float32Array(dots.length);
  for (let i = 0; i < dots.length; i++) {
    newDotSizes[i] = HIDDEN_SIZE;
  }

  // Set ambient
  for (let i = 0; i < dots.length; i++) {
    if(dots[i]._ambient) newDotSizes[i] = AMBIENT_SIZE;
  }

  // Rain
  for (let drop of rainDrops) {
    drop.y += drop.speed;
    if (drop.y > rows) drop.y = -8;
    for (let r = Math.floor(drop.y); r > drop.y - 6; r--) {
      if (r < 0 || r >= rows) continue;
      const idx = r * cols + drop.col;
      if (idx < newDotSizes.length)
        newDotSizes[idx] = Math.max(newDotSizes[idx], RAIN_SIZE);
    }
  }

  // Sea/water/foam
  for (let i = 0; i < dots.length; i++) {
    const { r, c } = positions[i];
    const s = surface[c];

    // Water
    if (r > s) {
      const depth = Math.min(1, (r - s) / SEA_HEIGHT_ROWS);
      const pulse = Math.sin(t * SEA_PULSE_SPEED + r * 0.4 + c * 0.3) * 0.6;
      const size = WATER_SIZE * (1 - depth * 0.35) + pulse;
      newDotSizes[i] = Math.max(newDotSizes[i], size);
    }
    // Foam
    else if (r >= s - FOAM_THICKNESS && r <= s + 0.3) {
      const size =
        FOAM_SIZE +
        Math.sin(t * FOAM_WAVE_SPEED + c * 0.9 + r) * 1.5 +
        Math.random() * 0.8;
      newDotSizes[i] = Math.max(newDotSizes[i], size);
    }
  }

  // Apply size changes efficiently (only when changed)
  for (let i = 0; i < dots.length; i++) {
    const size = newDotSizes[i];
    if (lastDotSizes[i] !== size) {
      dots[i].style.width = size + "px";
      dots[i].style.height = size + "px";
      lastDotSizes[i] = size;
    }
  }

  animFrameHandle = requestAnimationFrame(animate);
}

/* ---------------- VISIBILITY HANDLING ---------------- */

function onVisibilityChange() {
  if (document.hidden) {
    animationPaused = true;
    if (animFrameHandle !== null) {
      cancelAnimationFrame(animFrameHandle);
      animFrameHandle = null;
    }
  } else {
    if (animationPaused) {
      animationPaused = false;
      animate();
    }
  }
}
document.addEventListener("visibilitychange", onVisibilityChange);

/* ---------------- INIT ---------------- */

addEventListener("load", () => {
  createGrid();
  animate();
});

addEventListener("resize", () => {
  createGrid();
  // Keep lastDotSizes array in sync after resize
  lastDotSizes = new Array(dots.length).fill(HIDDEN_SIZE);
});
</script>
</body>
</html>
