<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Dynamic Rain Pattern - Dot Animation</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: auto;
    background: #0f0f0f;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE 10+ */
  }

  .dot {
    position: absolute;
    border-radius: 50%;
    background: #c9c9c9;
    pointer-events: none;
    transform-origin: center;
    will-change: width, height;
  }

  html::-webkit-scrollbar, body::-webkit-scrollbar {
    display: none;
    width: 0;
    height: 0;
  }
</style>
</head>
<body>
<script>
/* ---------------- CONFIGURATION ---------------- */
const SPACING_X = 12;
const SPACING_Y = 12;

const HIDDEN_SIZE = 0;
const AMBIENT_SIZE = 1.2;
const RAIN_SIZE = 6.5;
const WATER_SIZE = 6.8;
const FOAM_SIZE  = 8.5;

// Make sea bottom a little deeper by adding extra rows
// Keep EXTRA_ROWS at 0 so we only create DOM for the visible viewport.
// If you want a deeper sea effect, tweak SEA_HEIGHT_ROWS instead of adding off-screen rows.
const EXTRA_ROWS = 0;

const SEA_HEIGHT_ROWS = 10;
const FOAM_THICKNESS = 2;

const RAIN_COLUMNS_FRACTION = 0.07; // Fraction of columns with rain
const BASE_RAIN_SPEED = 0.15;       // Base speed for raindrops
const AMBIENT_CHANCE = 0.04;

// Memory / performance tuning
const MAX_DOTS = 18000; // cap total DOM nodes to this target
const MIN_FRAME_INTERVAL_MS = 1000 / 40; // limit to ~40 FPS to reduce CPU

/* ---------------- STATE ---------------- */
let dots = [];
let cols = 0;
let rows = 0;
let rainDropsPerRow = [];
let lastDotSizes = null;
let perFrameSizes = null; // typed array reused every frame
let spacingX = SPACING_X;
let spacingY = SPACING_Y;
let lastFrameTime = 0;

// Animation control
let animFrameHandle = null;
let isAnimating = false;

/* ---------------- GRID & INIT ---------------- */
function createGrid() {
  // Remove old
  dots.forEach(d => d.remove());
  dots = [];
  lastDotSizes = null;
  perFrameSizes = null;
  rainDropsPerRow = [];
  
  // Calculate grid size based on viewport
  // Start with base spacing
  spacingX = SPACING_X;
  spacingY = SPACING_Y;
  // Only create dots for the visible viewport â€” do NOT add extra non-visible rows
  let tentativeCols = Math.floor(window.innerWidth / spacingX);
  let tentativeRows = Math.floor(window.innerHeight / spacingY); // visible rows only
  // If too many dots, increase spacing to reduce count
  const tentativeTotal = tentativeCols * tentativeRows;
  if (tentativeTotal > MAX_DOTS) {
    const scale = Math.sqrt(tentativeTotal / MAX_DOTS);
    const multiplier = Math.ceil(scale);
    spacingX = SPACING_X * multiplier;
    spacingY = SPACING_Y * multiplier;
  }
  // Use ceil to ensure coverage of the viewport without creating off-screen rows/cols
  cols = Math.max(1, Math.ceil(window.innerWidth / spacingX));
  rows = Math.max(1, Math.ceil(window.innerHeight / spacingY));
  // Keep body constrained to the viewport to avoid creating off-screen DOM nodes
  document.body.style.minHeight = window.innerHeight + "px";
  document.body.style.minWidth = window.innerWidth + "px";
  
  // Create dots and keep track of rows/cols
  const frag = document.createDocumentFragment();
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const dot = document.createElement("div");
      dot.className = "dot";
      dot.style.left = c * spacingX + "px";
      dot.style.top  = r * spacingY + "px";
      dot.style.width = HIDDEN_SIZE + "px";
      dot.style.height = HIDDEN_SIZE + "px";
      frag.appendChild(dot);
      dots.push(dot);
      // ambient flag persisted on element
      if (!dot._ambient && Math.random() < AMBIENT_CHANCE) dot._ambient = true;
      if (Math.random() < AMBIENT_CHANCE) {
        dot._ambient = true;
      }
    }
  }
  document.body.appendChild(frag);
  // Initialize typed arrays and last sizes
  lastDotSizes = new Float32Array(dots.length);
  for (let i = 0; i < lastDotSizes.length; i++) lastDotSizes[i] = HIDDEN_SIZE;
  perFrameSizes = new Float32Array(dots.length);

  // Dynamically assign raindrops per row:
  rainDropsPerRow = [];
  for (let r = 0; r < rows; r++) {
    let thisRowDrops = [];
    // Fraction of columns for rain per row can be dynamic!
    const thisRowDropCount = Math.max(1, Math.round(cols * (RAIN_COLUMNS_FRACTION + Math.random()*0.02 - 0.01)));
    // Pick unique columns for this row
    let colIndices = Array.from({length: cols}, (_, i) => i);
    // Fisher-Yates shuffle to randomize
    for (let i = cols - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [colIndices[i], colIndices[j]] = [colIndices[j], colIndices[i]];
    }
    for (let d = 0; d < thisRowDropCount; d++) {
      thisRowDrops.push({
        col: colIndices[d],
        y: Math.random()*rows*0.7,
        speed: BASE_RAIN_SPEED + Math.random()*0.15
      });
    }
    rainDropsPerRow.push(thisRowDrops);
  }
}

/* ---------------- ANIMATION ENGINE ---------------- */
// You may adjust wave and foam dynamics below for more/less drama
const SEA_WAVE_SPEEDS = [0.30, 0.40, 0.30];
const SEA_PULSE_SPEED = 0.7;
const FOAM_WAVE_SPEED = 2.7;

function animate(now) {
  if (!isAnimating) return;
  if (!now) now = performance.now();
  // frame cap to reduce CPU on lower-end devices
  if (now - lastFrameTime < MIN_FRAME_INTERVAL_MS) {
    animFrameHandle = requestAnimationFrame(animate);
    return;
  }
  lastFrameTime = now;
  const t = now * 0.001;

  // Dynamic surface height for each col (wave effect, not per row)
  const surface = new Float32Array(cols);
  for (let c = 0; c < cols; c++) {
    surface[c] =
      rows - SEA_HEIGHT_ROWS +
      Math.sin(c * 0.12 + t * SEA_WAVE_SPEEDS[0]) * 2.4 +
      Math.sin(c * 0.27 - t * SEA_WAVE_SPEEDS[1]) * 1.2 +
      Math.cos(c * 0.18 + t * SEA_WAVE_SPEEDS[2]) * 0.6;
  }

  // Reuse per-frame typed array to avoid allocations
  if (!perFrameSizes || perFrameSizes.length !== dots.length) perFrameSizes = new Float32Array(dots.length);
  perFrameSizes.fill(HIDDEN_SIZE);

  // 1. Ambient: lowest priority, but only sets if empty
  for (let i = 0; i < dots.length; i++) if (dots[i]._ambient) perFrameSizes[i] = AMBIENT_SIZE;

  // 2. Rain: apply to each row DYNAMICALLY based on generated drops
  for (let r = 0; r < rows; r++) {
    if (!rainDropsPerRow[r]) continue;
    for (let drop of rainDropsPerRow[r]) {
      drop.y += drop.speed;
      if (drop.y > rows) drop.y = -6 - Math.random() * 4; // restart from above
      // Raindrop is only visible for a short "tail"
      for (let tail = 0; tail < 6; tail++) {
        const ry = Math.floor(drop.y) - tail;
        if (ry !== r) continue; // only if this is the current row
        if (ry < 0 || ry >= rows) continue;
        const i = ry * cols + drop.col;
        if (i >= 0 && i < perFrameSizes.length) perFrameSizes[i] = Math.max(perFrameSizes[i], RAIN_SIZE);
      }
    }
  }

  // 3. Water and foam layer (per row/col)
  for (let idx = 0; idx < dots.length; idx++) {
    // compute r,c on the fly to avoid per-dot position objects
    const r = Math.floor(idx / cols);
    const c = idx % cols;
    const s = surface[c];
    // Water below surface
    if (r > s) {
      const depth = Math.min(1, (r - s) / SEA_HEIGHT_ROWS);
      const pulse = Math.sin(t * SEA_PULSE_SPEED + r * 0.4 + c * 0.3) * 0.6;
      const size = WATER_SIZE * (1 - depth * 0.35) + pulse;
      perFrameSizes[idx] = Math.max(perFrameSizes[idx], size);
    }
    // Foam, on surface
    else if (r >= s - FOAM_THICKNESS && r <= s + 0.3) {
      const size = FOAM_SIZE + Math.sin(t * FOAM_WAVE_SPEED + c * 0.9 + r) * 1.5 + Math.random() * 0.8;
      perFrameSizes[idx] = Math.max(perFrameSizes[idx], size);
    }
  }

  // Efficient DOM updates (only if changed)
  for (let i = 0; i < dots.length; i++) {
    const size = perFrameSizes[i];
    if (lastDotSizes[i] !== size) {
      dots[i].style.width = size + "px";
      dots[i].style.height = size + "px";
      lastDotSizes[i] = size;
    }
  }
  animFrameHandle = requestAnimationFrame(animate);
}

/* ---------------- VISIBILITY & WINDOW HANDLING ---------------- */
// Pause animation when page/tab is not visible!
function handleVisibility() {
  if (document.visibilityState === 'visible') {
    if (!isAnimating) {
      isAnimating = true;
      animate();
    }
  } else {
    isAnimating = false;
    if (animFrameHandle != null) {
      cancelAnimationFrame(animFrameHandle);
      animFrameHandle = null;
    }
  }
}
document.addEventListener('visibilitychange', handleVisibility);

/* ---------------- RESIZE HANDLING ---------------- */
window.addEventListener("resize", () => {
  createGrid();
  // Sync lastDotSizes array after resize (typed array)
  lastDotSizes = new Float32Array(dots.length);
  for (let i = 0; i < lastDotSizes.length; i++) lastDotSizes[i] = HIDDEN_SIZE;

  // If page is not visible during resize, do not animate
  if (document.visibilityState === 'visible' && !isAnimating) {
    isAnimating = true;
    animate();
  }
});

/* ---------------- INIT ---------------- */
window.addEventListener("load", () => {
  createGrid();
  // Only animate if page is visible when loaded
  if (document.visibilityState === 'visible') {
    isAnimating = true;
    animate();
  }
});
</script>
</body>
</html>
