  <!DOCTYPE html>
<html lang="en">
<head>
    <title>Rutuj Dhodapkar - Portfolio</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="Rutuj Dhodapkar's portfolio: AI, ML, DL, software projects, skills, publications, and contact. Explore interactive demos, research, and more.">
    <meta name="keywords" content="Rutuj, Rutuj Dhodapkar, portfolio, AI, ML, DL, developer, projects, skills, research, publications, software engineer, personal website, interactive, Rutuj Dhodapkar Portfolio, Rutuj portfolio, Dhodapkar, Dhodapkar portfolio, innovation, technology, coding, programming, data science, neural networks, deep learning, artificial intelligence, machine learning, web development, open source, github, blog, contact, resume">
    <meta name="author" content="Rutuj Dhodapkar">
    <meta name="theme-color" content="#0f0f0f">
    <meta name="color-scheme" content="light dark">

    <!-- Open Graph / Facebook -->
    <meta property="og:title" content="Rutuj Dhodapkar | AI Student & Developer Portfolio">
    <meta property="og:description" content="Explore Rutuj Dhodapkar's portfolio: AI, ML, DL, software projects, interactive demos, research, and more.">
    <meta property="og:image" content="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png">
    <meta property="og:url" content="https://rutujdhodapkar.vercel.app">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Rutuj Dhodapkar Portfolio">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Rutuj Dhodapkar | AI Student & Developer Portfolio">
    <meta name="twitter:description" content="Explore Rutuj Dhodapkar's portfolio: AI, ML, DL, software projects, interactive demos, research, and more.">
    <meta name="twitter:image" content="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png">
    <meta name="twitter:site" content="@rutujdhodapkar">
    <meta name="twitter:creator" content="@rutujdhodapkar">

    <!-- Favicon and Manifest -->
    <link rel="icon" href="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png" type="image/svg+xml" sizes="any">
    <link rel="apple-touch-icon" sizes="180x180" href="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png" color="#0a192f">

    <!-- Preload critical images for performance -->
    <link rel="preload" href="static/diabetes.jpg" as="image" fetchpriority="high">
    <link rel="preload" href="static/instagram.png" as="image">
    <link rel="preload" href="static/x com.png" as="image">
    <link rel="preload" href="static/linkdin.png" as="image">
    <link rel="preload" href="static/github.png" as="image">
    <link rel="preload" href="static/mail.png" as="image">

    <!-- Preconnect for faster font and CDN loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

    <!-- Google Fonts: Modern, accessible, and performant -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Fira+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Required Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="styles.css">

    <!-- Custom Cursor Style -->
    <style>
      html, body {
        cursor: url('cursor.svg'), auto;
      }
    </style>

    <!-- Progressive Web App support -->
    <meta name="application-name" content="Rutuj Dhodapkar Portfolio">
    <meta name="apple-mobile-web-app-title" content="Rutuj Dhodapkar Portfolio">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-TileColor" content="#0a192f">
    <meta name="msapplication-TileImage" content="https://vectorseek.com/wp-content/uploads/2023/09/ADOBE-PORTFOLIO-Logo-Vector.svg-.png">

    <iframe 
        src="static/frame of index.html" 
        style="width:100vw; height:100vh; border:none; position:fixed; top:0; left:0; z-index:1; overflow:hidden;" 
        scrolling="auto">
    </iframe>

    <script>
      // Disable right-click context menu
      document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
      }, false);

      // Disable all keyboard input
      document.addEventListener('keydown', function(e) {
        e.preventDefault();
        return false;
      }, false);

      document.addEventListener('keypress', function(e) {
        e.preventDefault();
        return false;
      }, false);

      document.addEventListener('keyup', function(e) {
        e.preventDefault();
        return false;
      }, false);
    </script>
</head>

<body>
    <script>
      // --- ENHANCED CONFIG ---
      const PASSWORD = "supersecret";
      const CSV_URL = "https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/data.csv";
      const REPO = "rutujdhodapkar/Image-Hosting";
      const FILE = "userdata.csv";
      const TIMEOUT = 30000; // 30 second timeout
      const MAX_RETRIES = 3;
      let visitStart = Date.now();
      let debugMode = false; // Set to true for debugging
      
      // --- UTILITY FUNCTIONS ---
      function log(message, error = false) {
        if (debugMode) {
          error ? console.error(message) : console.log(message);
        }
      }
      
      function withTimeout(promise, timeoutMs) {
        return Promise.race([
          promise,
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Operation timed out')), timeoutMs)
          )
        ]);
      }
      
      // --- ENHANCED TOKEN HANDLING ---
      function decryptTokenLegacy(b64) {
        try {
          const raw = CryptoJS.enc.Base64.parse(b64);
          const iv = CryptoJS.enc.Utf8.parse("0000000000000000");
          const key = CryptoJS.SHA256(PASSWORD);
          const ciphertext = CryptoJS.lib.WordArray.create(raw.words.slice(4));
          const decrypted = CryptoJS.AES.decrypt({ciphertext}, key, {
            iv, 
            mode: CryptoJS.mode.CBC, 
            padding: CryptoJS.pad.Pkcs7
          });
          return decrypted.toString(CryptoJS.enc.Utf8);
        } catch (e) {
          log('Legacy token decryption failed: ' + e.message, true);
          throw e;
        }
      }

      function decryptTokenModern(encrypted) {
        try {
          const decrypted = CryptoJS.AES.decrypt(encrypted, PASSWORD);
          return decrypted.toString(CryptoJS.enc.Utf8);
        } catch (e) {
          log('Modern token decryption failed: ' + e.message, true);
          throw e;
        }
      }

      async function getEncryptedToken() {
        try {
          log('Fetching token from CSV...');
          const response = await withTimeout(fetch(CSV_URL), TIMEOUT);
          
          if (!response.ok) {
            throw new Error(`Failed to fetch CSV: ${response.status} ${response.statusText}`);
          }
          
          const text = await response.text();
          log('CSV content received, parsing...');
          
          // Enhanced CSV parsing with error handling
          try {
            const parsed = Papa.parse(text, {
              header: true,
              skipEmptyLines: true,
              transformHeader: header => header.trim().toLowerCase()
            });
            
            if (parsed.errors && parsed.errors.length > 0) {
              log('CSV parsing warnings: ' + JSON.stringify(parsed.errors));
            }
            
            if (parsed.data && parsed.data.length > 0) {
              const firstRow = parsed.data[0];
              if (firstRow.token) {
                log('Token found in parsed CSV');
                return firstRow.token;
              }
            }
          } catch (parseError) {
            log('Papa Parse failed, trying manual parsing: ' + parseError.message);
          }
          
          // Fallback: manual parsing
          const lines = text.split('\n');
          for (let line of lines) {
            if (line.toLowerCase().includes('token')) {
              const parts = line.split(',');
              if (parts.length >= 2) {
                return parts[1].trim().replace(/['"]/g, '');
              }
            }
          }
          
          throw new Error('No token found in CSV');
        } catch (error) {
          log('Failed to get encrypted token: ' + error.message, true);
          throw error;
        }
      }

      // --- COMPREHENSIVE DATA COLLECTION ---
      
      // Enhanced IP detection with multiple STUN servers
      async function getAllIPs() {
        const ips = new Set();
        const stunServers = [
          'stun:stun.l.google.com:19302',
          'stun:stun1.l.google.com:19302',
          'stun:stun2.l.google.com:19302',
          'stun:stun.cloudflare.com:3478',
          'stun:stun.nextcloud.com:443',
          'stun:stun.freeswitch.org:3478'
        ];
        
        for (let stunServer of stunServers) {
          try {
            const pc = new RTCPeerConnection({
              iceServers: [{ urls: stunServer }],
              iceCandidatePoolSize: 10
            });
            
            pc.createDataChannel('');
            
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            await new Promise((resolve) => {
              const timeout = setTimeout(resolve, 3000);
              let candidateCount = 0;
              
              pc.onicecandidate = (e) => {
                if (e.candidate) {
                  candidateCount++;
                  const candidate = e.candidate.candidate;
                  
                  // Extract IPv4 addresses
                  const ipv4Match = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                  if (ipv4Match) {
                    ips.add(ipv4Match[1]);
                  }
                  
                  // Extract IPv6 addresses
                  const ipv6Match = candidate.match(/([0-9a-f:]+:+[0-9a-f]+)/i);
                  if (ipv6Match && ipv6Match[1].includes(':')) {
                    ips.add(ipv6Match[1]);
                  }
                } else if (candidateCount > 0) {
                  clearTimeout(timeout);
                  resolve();
                }
              };
            });
            
            pc.close();
          } catch (error) {
            log(`STUN server ${stunServer} failed: ${error.message}`);
          }
        }
        
        return Array.from(ips);
      }

      // Canvas fingerprinting implementation
      function getCanvasFingerprint() {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = 280;
          canvas.height = 60;
          
          // Draw complex pattern for better uniqueness
          ctx.textBaseline = 'top';
          ctx.font = '14px Arial, sans-serif';
          ctx.fillStyle = '#f60';
          ctx.fillRect(125, 1, 62, 20);
          
          ctx.fillStyle = '#069';
          ctx.fillText('Canvas fingerprint test 🔒', 2, 15);
          
          ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
          ctx.fillText('Canvas fingerprint test 🔒', 4, 17);
          
          // Add some shapes for better variance
          ctx.globalCompositeOperation = 'multiply';
          ctx.fillStyle = 'rgb(255,0,255)';
          ctx.beginPath();
          ctx.arc(50, 50, 50, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fill();
          
          const imageData = canvas.toDataURL();
          
          // Generate hash of the canvas
          let hash = 0;
          for (let i = 0; i < imageData.length; i++) {
            const char = imageData.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
          }
          
          return Math.abs(hash).toString(16);
        } catch (error) {
          log('Canvas fingerprinting failed: ' + error.message, true);
          return 'unavailable';
        }
      }
      
      // WebGL fingerprinting implementation
      function getWebGLFingerprint() {
        try {
          const canvas = document.createElement('canvas');
          const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
          
          if (!gl) return 'unsupported';
          
          const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
          let fingerprint = '';
          
          if (debugInfo) {
            fingerprint += gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || '';
            fingerprint += '|' + (gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || '');
          }
          
          fingerprint += '|' + (gl.getParameter(gl.VERSION) || '');
          fingerprint += '|' + (gl.getParameter(gl.SHADING_LANGUAGE_VERSION) || '');
          fingerprint += '|' + (gl.getParameter(gl.VENDOR) || '');
          fingerprint += '|' + (gl.getParameter(gl.RENDERER) || '');
          
          // Get supported extensions
          const extensions = gl.getSupportedExtensions();
          if (extensions) {
            fingerprint += '|' + extensions.sort().join(',');
          }
          
          // Generate hash
          let hash = 0;
          for (let i = 0; i < fingerprint.length; i++) {
            const char = fingerprint.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
          }
          
          return Math.abs(hash).toString(16);
        } catch (error) {
          log('WebGL fingerprinting failed: ' + error.message, true);
          return 'unavailable';
        }
      }
      
      // Audio fingerprinting implementation
      function getAudioFingerprint() {
        return new Promise((resolve) => {
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            if (!audioContext) {
              resolve('unsupported');
              return;
            }
            
            const oscillator = audioContext.createOscillator();
            const analyser = audioContext.createAnalyser();
            const gainNode = audioContext.createGain();
            const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
            
            oscillator.type = 'triangle';
            oscillator.frequency.value = 1000;
            
            gainNode.gain.value = 0;
            
            oscillator.connect(analyser);
            analyser.connect(scriptProcessor);
            scriptProcessor.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(0);
            
            scriptProcessor.onaudioprocess = function(bins) {
              const samples = bins.inputBuffer.getChannelData(0);
              let fingerprint = '';
              
              for (let i = 0; i < samples.length; i++) {
                if (samples[i] !== 0) {
                  fingerprint += Math.abs(samples[i]).toString(36);
                  if (fingerprint.length > 50) break;
                }
              }
              
              oscillator.stop(0);
              audioContext.close();
              
              // Generate hash
              let hash = 0;
              for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
              }
              
              resolve(Math.abs(hash).toString(16) || 'unavailable');
            };
            
            setTimeout(() => {
              try {
                oscillator.stop(0);
                audioContext.close();
              } catch (e) {}
              resolve('timeout');
            }, 1000);
            
          } catch (error) {
            log('Audio fingerprinting failed: ' + error.message, true);
            resolve('unavailable');
          }
        });
      }
      
      // Enhanced device media detection
      async function getMediaDevices() {
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            return { audioInputs: 0, videoInputs: 0, audioOutputs: 0 };
          }
          
          const devices = await navigator.mediaDevices.enumerateDevices();
          
          return {
            audioInputs: devices.filter(d => d.kind === 'audioinput').length,
            videoInputs: devices.filter(d => d.kind === 'videoinput').length,
            audioOutputs: devices.filter(d => d.kind === 'audiooutput').length,
            deviceList: devices.map(d => `${d.kind}:${d.label || 'unnamed'}`).join(';')
          };
        } catch (error) {
          log('Media device detection failed: ' + error.message, true);
          return { audioInputs: 0, videoInputs: 0, audioOutputs: 0, deviceList: 'unavailable' };
        }
      }
      
      // Enhanced geolocation data
      async function getIPInfo() {
        const apis = [
          'https://ipapi.co/json/',
          'https://ip-api.com/json/',
          'https://ipinfo.io/json'
        ];
        
        for (let api of apis) {
          try {
            log(`Trying IP API: ${api}`);
            const response = await withTimeout(fetch(api), 10000);
            if (response.ok) {
              const data = await response.json();
              log('IP info retrieved successfully');
              return data;
            }
          } catch (error) {
            log(`IP API ${api} failed: ${error.message}`);
            continue;
          }
        }
        
        log('All IP APIs failed', true);
        return {};
      }
      
      // Enhanced privacy detection
      function detectAdblock() {
        return new Promise(resolve => {
          const bait = document.createElement('div');
          bait.className = 'adsbox ads ad pub_300x250 pub_300x250m pub_728x90 text-ad textAd text_ad text_ads text-ads text-ad-links';
          bait.style = 'width:1px;height:1px;position:absolute;left:-9999px;top:-9999px;';
          document.body.appendChild(bait);
          
          setTimeout(() => {
            const blocked = bait.offsetHeight === 0 || 
                           bait.offsetWidth === 0 || 
                           window.getComputedStyle(bait).display === 'none';
            bait.remove();
            resolve(blocked);
          }, 100);
        });
      }

      function detectIncognito() {
        return new Promise(resolve => {
          if (navigator.storage && navigator.storage.estimate) {
            navigator.storage.estimate().then(estimate => {
              resolve(estimate.quota < 120000000);
            }).catch(() => resolve(false));
          } else {
            resolve(false);
          }
        });
      }

      function detectPrivateMode() {
        return new Promise(resolve => {
          if (window.webkitRequestFileSystem) {
            window.webkitRequestFileSystem(0, 1, () => resolve(false), () => resolve(true));
          } else if (window.indexedDB && /Firefox/.test(navigator.userAgent)) {
            try {
              const db = indexedDB.open('test');
              db.onerror = () => resolve(true);
              db.onsuccess = () => resolve(false);
            } catch (e) {
              resolve(true);
            }
          } else {
            resolve(false);
          }
        });
      }
      
      // Enhanced battery detection
      async function getBatteryInfo() {
        try {
          if (navigator.getBattery) {
            const battery = await withTimeout(navigator.getBattery(), 5000);
            return {
              level: Math.round(battery.level * 100),
              charging: battery.charging,
              chargingTime: battery.chargingTime,
              dischargingTime: battery.dischargingTime
            };
          }
          return { level: 'unknown', charging: 'unknown', chargingTime: 'unknown', dischargingTime: 'unknown' };
        } catch (error) {
          log('Battery info failed: ' + error.message, true);
          return { level: 'unavailable', charging: 'unavailable', chargingTime: 'unavailable', dischargingTime: 'unavailable' };
        }
      }
      
      // Enhanced VPN/Tor detection
      function detectVPN(org, ip) {
        const vpnKeywords = /vpn|proxy|cloudflare|digitalocean|linode|aws|ovh|google cloud|azure|hosting|server|datacenter/i;
        const vpnFromOrg = vpnKeywords.test(org || "");
        
        // Check for common VPN IP ranges
        const vpnRanges = [
          /^10\./,
          /^172\.(1[6-9]|2[0-9]|3[01])\./,
          /^192\.168\./,
          /^169\.254\./
        ];
        
        const privateIP = vpnRanges.some(range => range.test(ip || ""));
        
        return {
          detected: vpnFromOrg,
          confidence: vpnFromOrg ? (privateIP ? 'high' : 'medium') : 'low',
          reasons: []
        };
      }

      function detectTor(org, userAgent) {
        const torKeywords = /tor|onion|relay|exit|guard/i;
        const torFromOrg = torKeywords.test(org || "");
        
        // Check for Tor browser user agent patterns
        const torBrowser = /Tor Browser/.test(userAgent || "");
        
        // Low entropy check (common Tor Browser characteristic)
        const lowEntropy = navigator.hardwareConcurrency <= 2 && 
                          screen.width === 1000 && 
                          screen.height === 1000;
        
        return {
          detected: torFromOrg || torBrowser || lowEntropy,
          confidence: torBrowser ? 'high' : (torFromOrg ? 'medium' : 'low'),
          reasons: [
            torFromOrg && 'org_keywords',
            torBrowser && 'user_agent',
            lowEntropy && 'low_entropy'
          ].filter(Boolean)
        };
      }
      
      // Main data collection function
      async function collectData() {
        log('Starting comprehensive data collection...');
        
        try {
          const startTime = Date.now();
          
          // Collect all data in parallel where possible
          const [
            ipInfo,
            allIPs,
            adblock,
            incognito,
            privateMode,
            battery,
            mediaDevices,
            canvasFingerprint,
            webglFingerprint,
            audioFingerprint
          ] = await Promise.all([
            getIPInfo(),
            getAllIPs(),
            detectAdblock(),
            detectIncognito(),
            detectPrivateMode(),
            getBatteryInfo(),
            getMediaDevices(),
            getCanvasFingerprint(),
            getWebGLFingerprint(),
            getAudioFingerprint()
          ]);
          
          const now = new Date();
          const collectionTime = Date.now() - startTime;
          
          // Enhanced GPU info
          const gpu = (() => {
            try {
              const canvas = document.createElement('canvas');
              const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
              if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                  return {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Unknown',
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Unknown',
                    driver: gl.getParameter(gl.VERSION) || 'Unknown'
                  };
                }
              }
              return { vendor: 'WebGL Unavailable', renderer: 'WebGL Unavailable', driver: 'WebGL Unavailable' };
            } catch (error) {
              return { vendor: 'Error', renderer: 'Error', driver: 'Error' };
            }
          })();
          
          // Enhanced CPU detection
          const cpu = (() => {
            const ua = navigator.userAgent;
            if (/Intel/i.test(ua)) return 'Intel';
            if (/AMD/i.test(ua)) return 'AMD';
            if (/Apple/i.test(ua) || /Mac/i.test(ua)) return 'Apple Silicon';
            if (/ARM/i.test(ua)) return 'ARM';
            return 'Unknown';
          })();

          // Try to get CPU brand string (modern browsers)
          let cpuBrand = 'unknown';
          if (navigator.userAgentData && navigator.userAgentData.brands) {
            const cpuBrandObj = navigator.userAgentData.brands.find(b => /intel|amd|apple|arm/i.test(b.brand));
            if (cpuBrandObj) cpuBrand = cpuBrandObj.brand;
          }

          // Try to get browser name/version (modern browsers)
          let browser = 'unknown';
          if (navigator.userAgentData && navigator.userAgentData.brands) {
            browser = navigator.userAgentData.brands.map(b => `${b.brand} ${b.version}`).join(';');
          } else if (navigator.userAgent) {
            // Fallback: parse userAgent string
            const ua = navigator.userAgent;
            if (/chrome|crios|crmo/i.test(ua)) browser = 'Chrome';
            else if (/firefox|fxios/i.test(ua)) browser = 'Firefox';
            else if (/safari/i.test(ua)) browser = 'Safari';
            else if (/edg/i.test(ua)) browser = 'Edge';
            else if (/opr\//i.test(ua)) browser = 'Opera';
            else if (/msie|trident/i.test(ua)) browser = 'IE';
            else browser = ua.split(' ')[0];
          }

          // VPN/Tor detection
          const vpnDetection = detectVPN(ipInfo.org, ipInfo.ip);
          const torDetection = detectTor(ipInfo.org, navigator.userAgent);

          // Compose all local IPs as string
          const localIPs = allIPs.filter(ip => /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/.test(ip)).join(';');

          // Compose timestamp (epoch ms)
          const timestamp = Date.now();

          // Compose totalTime (same as timeOnPageSec for now)
          const totalTime = ((Date.now() - visitStart) / 1000).toFixed(1);

          // Compose vpn and tor fields (string, for compatibility)
          const vpn = vpnDetection.detected ? 'yes' : 'no';
          const tor = torDetection.detected ? 'yes' : 'no';

          // Compose deviceMemoryGB (number, if available)
          let deviceMemoryGB = 'unknown';
          if (navigator.deviceMemory) deviceMemoryGB = navigator.deviceMemory;

          // Compose battery (object as JSON string for CSV)
          const batteryObj = {
            level: battery.level,
            charging: battery.charging,
            chargingTime: battery.chargingTime,
            dischargingTime: battery.dischargingTime
          };
          const batteryStr = JSON.stringify(batteryObj);

          // Compose gpu (object as JSON string for CSV)
          const gpuObj = {
            vendor: gpu.vendor,
            renderer: gpu.renderer,
            driver: gpu.driver
          };
          const gpuStr = JSON.stringify(gpuObj);

          // Compose cpu (string)
          const cpuStr = cpu;

          // Compose languages (array or string)
          const languages = (navigator.languages || []).join(',');

          // Compose doNotTrack (string)
          const doNotTrack = navigator.doNotTrack || 'not_specified';

          // Compose javaEnabled (bool)
          const javaEnabled = typeof navigator.javaEnabled === 'function' ? navigator.javaEnabled() : false;

          // Compose allIPs (string)
          const allIPsStr = allIPs.join(';');

          // Compose hasLocalIPs/hasPublicIPs
          const hasLocalIPs = allIPs.some(ip => /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/.test(ip));
          const hasPublicIPs = allIPs.some(ip => !/^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|169\.254\.)/.test(ip));

          // Compose performanceMemory (object or unavailable)
          const performanceMemory = performance.memory ? {
            usedJSHeapSize: performance.memory.usedJSHeapSize,
            totalJSHeapSize: performance.memory.totalJSHeapSize,
            jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
          } : 'unavailable';

          // Compose sessionId/visitId
          const sessionId = Math.random().toString(36).substr(2, 9);
          const visitId = `${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;

          // Compose the full data object, adding all missing fields
          const comprehensiveData = {
            // --- Requested fields ---
            visitTimestampUTC: now.toISOString(),
            localTime: now.toString(),
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            timeOffset: now.getTimezoneOffset(),
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            languages: languages,
            cpuCores: navigator.hardwareConcurrency || 'unknown',
            deviceMemoryGB: deviceMemoryGB,
            cookieEnabled: navigator.cookieEnabled,
            doNotTrack: doNotTrack,
            referrer: document.referrer || 'direct',
            pageURL: location.href,
            screenResolution: `${screen.width}x${screen.height}`,
            availableScreen: `${screen.availWidth}x${screen.availHeight}`,
            colorDepth: screen.colorDepth,
            pixelDepth: screen.pixelDepth,
            refreshRate: screen.refreshRate || 'unknown',
            gpuVendor: gpu.vendor,
            gpuRenderer: gpu.renderer,
            gpuDriver: gpu.driver,
            battery: batteryStr,
            timeOnPageSec: ((Date.now() - visitStart) / 1000).toFixed(1),
            ip: ipInfo.ip || 'unknown',
            city: ipInfo.city || 'unknown',
            region: ipInfo.region || ipInfo.region_name || 'unknown',
            country: ipInfo.country || ipInfo.country_name || 'unknown',
            latitude: ipInfo.latitude || ipInfo.lat || 'unknown',
            longitude: ipInfo.longitude || ipInfo.lon || 'unknown',
            org: ipInfo.org || ipInfo.organization || 'unknown',
            localIPs: localIPs,
            timestamp: timestamp,
            browser: browser,
            gpu: gpuStr,
            cpu: cpuStr,
            adblock: adblock,
            incognito: incognito,
            privateMode: privateMode,
            vpnDetected: vpnDetection.detected,
            torDetected: torDetection.detected,
            totalTime: totalTime,
            cpuBrand: cpuBrand,
            vpn: vpn,
            tor: tor,
            collectionTimeMs: collectionTime,
            language: navigator.language,
            javaEnabled: javaEnabled,
            protocol: location.protocol,
            host: location.host,
            pathname: location.pathname,
            screenOrientation: screen.orientation ? screen.orientation.type : 'unknown',
            pixelRatio: window.devicePixelRatio || 1,
            deviceMemory: navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'unknown',
            batteryLevel: battery.level,
            batteryCharging: battery.charging,
            batteryChargingTime: battery.chargingTime,
            batteryDischargingTime: battery.dischargingTime,
            countryCode: ipInfo.country_code || 'unknown',
            isp: ipInfo.isp || 'unknown',
            timezone_ip: ipInfo.timezone || 'unknown',
            allIPs: allIPsStr,
            ipCount: allIPs.length,
            hasLocalIPs: hasLocalIPs,
            hasPublicIPs: hasPublicIPs,
            adblockDetected: adblock,
            incognitoMode: incognito,
            vpnConfidence: vpnDetection.confidence,
            torConfidence: torDetection.confidence,
            torReasons: torDetection.reasons.join(','),
            audioInputDevices: mediaDevices.audioInputs,
            videoInputDevices: mediaDevices.videoInputs,
            audioOutputDevices: mediaDevices.audioOutputs,
            mediaDevicesList: mediaDevices.deviceList,
            canvasFingerprint: canvasFingerprint,
            webglFingerprint: webglFingerprint,
            audioFingerprint: audioFingerprint,
            connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown',
            connectionDownlink: navigator.connection ? navigator.connection.downlink : 'unknown',
            connectionRTT: navigator.connection ? navigator.connection.rtt : 'unknown',
            pluginCount: navigator.plugins ? navigator.plugins.length : 0,
            plugins: navigator.plugins ? Array.from(navigator.plugins).map(p => p.name).join(';') : 'unavailable',
            performanceMemory: performanceMemory,
            webgl: !!window.WebGLRenderingContext,
            webgl2: !!window.WebGL2RenderingContext,
            webrtc: !!(window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection),
            mediaDevicesAPI: !!navigator.mediaDevices,
            geolocationAPI: !!navigator.geolocation,
            notificationAPI: !!window.Notification,
            serviceWorker: !!navigator.serviceWorker,
            webAssembly: !!window.WebAssembly,
            sessionId: sessionId,
            visitId: visitId,
            // --- End requested fields ---
          };
          
          log(`Data collection completed in ${collectionTime}ms`);
          return comprehensiveData;
          
        } catch (error) {
          log('Data collection failed: ' + error.message, true);
          throw error;
        }
      }

      // Enhanced GitHub upload with retry mechanism
      async function uploadToGitHub(token, newData) {
        const url = `https://api.github.com/repos/${REPO}/contents/${FILE}`;
        
        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
          try {
            log(`GitHub upload attempt ${attempt}/${MAX_RETRIES}`);
            
            const headers = {
              "Authorization": `token ${token}`,
              "Content-Type": "application/json",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28"
            };

            let csv = "";
            let sha = null;
            let keys = Object.keys(newData);

            // Try to get existing file
            const getResponse = await withTimeout(fetch(url, { headers }), TIMEOUT);
            
            if (getResponse.status === 200) {
              const existingFile = await getResponse.json();
              const existingContent = atob(existingFile.content.replace(/\n/g, ""));
              
              try {
                const parsed = Papa.parse(existingContent, {
                  header: true,
                  skipEmptyLines: true,
                  transformHeader: header => header.trim()
                });
                
                // Merge column headers
                keys = [...new Set([...(parsed.meta.fields || []), ...keys])];
                
                // Create CSV with existing data plus new row
                const existingRows = parsed.data.filter(row => 
                  Object.values(row).some(value => value && value.toString().trim())
                );
                
                const allRows = existingRows.map(row => 
                  keys.map(key => `"${(row[key] || '').toString().replace(/"/g, '""')}"`)
                );
                
                allRows.push(keys.map(key => 
                  `"${(newData[key] || '').toString().replace(/"/g, '""')}"`
                ));
                
                csv = [keys.join(','), ...allRows.map(row => row.join(','))].join('\n');
                sha = existingFile.sha;
                
              } catch (parseError) {
                log('Failed to parse existing CSV, creating new file: ' + parseError.message);
                csv = [keys.join(','), keys.map(k => `"${(newData[k] || '').toString().replace(/"/g, '""')}"`).join(',')].join('\n');
              }
            } else if (getResponse.status === 404) {
              // File doesn't exist, create new
              log('File does not exist, creating new file');
              csv = [keys.join(','), keys.map(k => `"${(newData[k] || '').toString().replace(/"/g, '""')}"`).join(',')].join('\n');
            } else {
              throw new Error(`Failed to check existing file: ${getResponse.status} ${getResponse.statusText}`);
            }

            // Upload the file
            const uploadBody = {
              message: `Log visitor data - ${new Date().toISOString()}`,
              content: btoa(csv),
              ...(sha && { sha })
            };

            const uploadResponse = await withTimeout(fetch(url, {
              method: "PUT",
              headers,
              body: JSON.stringify(uploadBody)
            }), TIMEOUT);

            if (!uploadResponse.ok) {
              const errorText = await uploadResponse.text();
              throw new Error(`Upload failed: ${uploadResponse.status} ${uploadResponse.statusText} - ${errorText}`);
            }

            const result = await uploadResponse.json();
            log('GitHub upload successful: ' + result.commit.sha);
            return result;

          } catch (error) {
            log(`GitHub upload attempt ${attempt} failed: ${error.message}`, true);
            
            if (attempt === MAX_RETRIES) {
              throw error;
            }
            
            // Wait before retry (exponential backoff)
            await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
          }
        }
      }

      // Main execution function
      async function executeDataCollection() {
        try {
          log('=== Starting Data Collection Process ===');
          
          // Get and decrypt token
          const encrypted = await getEncryptedToken();
          if (!encrypted) {
            throw new Error('No encrypted token found');
          }
          
          let token = null;
          
          // Try both decryption methods
          try {
            token = decryptTokenLegacy(encrypted);
            log('Token decrypted using legacy method');
          } catch (e) {
            try {
              token = decryptTokenModern(encrypted);
              log('Token decrypted using modern method');
            } catch (e2) {
              throw new Error('Both token decryption methods failed');
            }
          }
          
          if (!token || token.length < 10) {
            throw new Error('Invalid token received');
          }
          
          // Collect comprehensive data
          const data = await collectData();
          
          // Upload to GitHub
          await uploadToGitHub(token, data);
          
          log('=== Data Collection Process Completed Successfully ===');
          
        } catch (error) {
          log('=== Data Collection Process Failed ===', true);
          log('Error details: ' + error.message, true);
          
          // In production, you might want to send error reports to a logging service
          // For now, we fail silently as requested
        }
      }

      // Execute immediately and set up page unload handler
      executeDataCollection();

      // Track time spent and upload on page unload
      let timeSpent = 0;
      const timeTracker = setInterval(() => timeSpent++, 1000);

      window.addEventListener("beforeunload", () => {
        clearInterval(timeTracker);
        
        // Use sendBeacon for more reliable unload data sending
        if (navigator.sendBeacon) {
          executeDataCollection().then(() => {
            log('Unload data collection completed');
          }).catch(error => {
            log('Unload data collection failed: ' + error.message, true);
          });
        }
      });

      // Also handle visibility changes (when user switches tabs)
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === 'hidden') {
          executeDataCollection().catch(() => {
            // Silent fail
          });
        }
      });

    </script>
</body>
</html>
